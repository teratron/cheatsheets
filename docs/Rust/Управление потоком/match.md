*Теги*: [[Rust]], [[Управление потоком]], [[Деструктуризация]]

```rust
fn main() {
    let number = 13;

    println!("Расскажите мне о {}", number);
    
    match number {
        // Match a single value
        1 => println!("Один!"),
        
        // Match several values
        2 | 3 | 5 | 7 | 11 => println!("Это простое число"),

        // Выбирает диапазон, включающий границы
        13..=19 => println!("от 13 до 19"),
        
        // Обрабатывает оставшиеся случаи
        _ => println!("Ничего особенногоl"),
    }

    let boolean = true;
    let binary = match boolean {
        // Ветви оператора match должны перечислять все возможные значения
        false => 0,
        true => 1,
    };

    println!("{} -> {}", boolean, binary);
}
```

## Деструктуризация

### Кортежи

```rust
fn main() {
    let triple = (0, -2, 3);

    println!("Расскажите мне о {:?}", triple);

    match triple {
        // Деструктурируем второй и третий элементы
        (0, y, z) => println!("Первый = 0, y = {:?}, а z = {:?}", y, z),
        (1, ..) => println!("Первый = 1, а остальное не важно"),
        (.., 2) => println!("Последний = 2, а остальное не важно"),
        (3, .., 4) => println!("Первый = 3, последний = 4, а остальное не важно"),
        // `..` можно использовать, чтобы игнорировать оставшуюся часть кортежа
        
        // `_` означает, значение не будет присвоено переменной
        _ => println!("Не важно чему они равны"),
    }
}
```

### Перечисления

```rust
// `allow` необходим, чтобы компилятор не выводил предупреждения,
// т.к используется только один вариант
#[allow(dead_code)]
enum Color {
    // Эти 3 перечисления определяют цвет по названию.
    Red,
    Blue,
    Green,
    // Остальные используют `u32` кортежи для идентификации цветовых моделей.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);

    println!("Какой это цвет?");

    match color {
        Color::Red   => println!("Красный цвет!"),
        Color::Blue  => println!("Синий цвет!"),
        Color::Green => println!("Зелёный цвет!"),
        Color::RGB(r, g, b) =>
            println!("Красный: {}, зелёный: {}, и синий: {}!", r, g, b),
        Color::HSV(h, s, v) =>
            println!("Тон: {}, насыщенность: {}, значение: {}!", h, s, v),
        Color::HSL(h, s, l) =>
            println!("Тон: {}, насыщенность: {}, светлота: {}!", h, s, l),
        Color::CMY(c, m, y) =>
            println!("Голубой: {}, пурпурный: {}, жёлтый: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =>
            println!("Голубой: {}, пурпурный: {}, жёлтый: {}, key (чёрный): {}!",
                c, m, y, k),
        // Нет необходимости в других ветвях, т.к были рассмотрены все варианты
    }
}
```

### Указатели и ссылки

- Разыменование использует `*`
- Деструктуризация использует `&`, `ref` и `ref mut`

```rust
fn main() {
    // Присваиваем ссылку на тип `i32`.
    // Символ `&` означает, что присваивается ссылка.
    let reference = &4;

    match reference {
        &val => println!("Получаем значение через деструктуризацию: {:?}", val),
    }

    // Чтобы избежать символа `&`, нужно разыменовывать ссылку до сопоставления.
    match *reference {
        val => println!("Получаем значение через разыменование: {:?}", val),
    }

    // Что если у нас нет ссылки? `reference` была с `&`,
    // потому что правая часть была ссылкой. Но это не ссылка,
    // потому что правая часть ею не является.
    let _not_a_reference = 3;

    // Rust предоставляет ключевое слово `ref` именно для этой цели.
    // Оно изменяет присваивание так, что создаётся ссылка для элемента.
    // Теперь ссылка присвоена.
    let ref _is_a_reference = 3;

    // Соответственно, для определения двух значений без ссылок,
    // ссылки можно назначить с помощью `ref` и `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Используйте ключевое слово `ref` для создания ссылки.
    match value {
        ref r => println!("Получили ссылку на значение: {:?}", r),
    }

    // Используйте `ref mut` аналогичным образом.
    match mut_value {
        ref mut m => {
            // Получаем ссылку. Её нужно разыменовать,
            // прежде чем мы сможем что-то добавить.
            *m += 10;
            println!("Мы добавили 10. `mut_value`: {:?}", m);
        },
    }
}
```

### Структуры

```rust
fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // деструктуризация члена структуры
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;
    println!("a = {}, b = {},  y = {} ", a, b, y);

    // Вы можете деструктурировать структуру и переименовывать переменные,
    // порядок при этом не важен
    let Foo { y: i, x: j } = foo;
    println!("i = {:?}, j = {:?}", i, j);

    // а так же можно проигнорировать часть переменных:
    let Foo { y, .. } = foo;
    println!("y = {}", y);
}
```

## Ограничители шаблонов

```rust
fn main() {
    let pair = (2, -2);

    println!("Расскажи мне о {:?}", pair);

    match pair {
        (x, y) if x == y => println!("Близнецы"),
        // Данное ^ `условие if` является ограничителем шаблонов
        (x, y) if x + y == 0 => println!("Антиматерия, бабах!"),
        (x, _) if x % 2 == 1 => println!("Первое число нечётно"),
        _ => println!("Нет корреляции..."),
    }
}
```

## Связывание

```rust
fn age() -> u32 {
    15
}

fn main() {
    println!("Скажи мне свой возраст");

    match age() {
        0 => println!("Я ещё не отпраздновал свой первый день рождения"),
        // Можно было бы использовать только 1 ... 12 в `match`,
        // но какого возраста тогда был бы ребёнок? Вместо этого мы
        // привязываем `n` к последовательности 1 .. 12. 
        // Теперь мы можем сообщить возраст.
        n @ 1  ..= 12 => println!("Я ребёнок. Мне {:?}", n),
        n @ 13 ..= 19 => println!("Я подросток. Мне {:?}", n),
        // Ничего не привязываем.
        n => println!("Я взрослый. Мне {:?}", n),
    }
}
```

```rust
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // Вариант `Some`, выбираем, если его значение, привязанное к `n`,
        // равно 42.
        Some(n @ 42) => println!("Ответ: {}!", n),
        // При других числах.
        Some(n)      => println!("Не интересно... {}", n),
        // Для всего остального (вариант `None`).
        _ => (),
    }
}
```
